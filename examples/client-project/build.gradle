/**
 * This project shows various ways of invoking Flux via Gradle. Each example depends on connecting to the example
 * application deployed via the "../getting-started" project.
 */
import com.marklogic.flux.api.Flux

buildscript {
  repositories {
    mavenCentral()
    mavenLocal()
  }
  dependencies {
    classpath "com.marklogic:flux-api:1.4.0"
  }

  // This is required when a plugin, such as ml-gradle, is on the classpath that brings along a version of Jackson
  // that is incompatible with the version of Apache Spark used by Flux.
  configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
      if (details.requested.group.startsWith('com.fasterxml.jackson')) {
        details.useVersion '2.15.2'
        details.because 'Must ensure the Jackson version preferred by Spark is used to avoid classpath conflicts.'
      }
    }
  }
}

plugins {
  id "java"

  // Include ml-gradle to verify that it can be used on the buildscript classpath along with flux-api without any
  // class conflicts pertaining to OkHttp or Jackson.
  // Can run "./gradlew mlTestConnections -PmlUsername=admin -PmlPassword=admin -PmlRestPort=8000" to verify that
  // ml-gradle is able to connect to MarkLogic. This works as of Flux 1.3.0, but had classpath issues with Flux 1.2.x
  // and earlier.
  id "com.marklogic.ml-gradle" version "5.0.0"
}

repositories {
  mavenCentral()
  mavenLocal()
}

dependencies {
  implementation "com.marklogic:flux-api:1.4.0"
  implementation "com.marklogic:flux-embedding-model-minilm:1.4.0"
}

/**
 * Demonstrates how a custom program can be written that depends on the "flux-api" and "flux-embedding-model-minilm"
 * dependencies. Requires Java 17 and use of the Gradle "java" plugin.
 */
tasks.register("runCustomProgram", JavaExec) {
  mainClass = "org.example.CustomProgram"
  classpath = sourceSets.main.runtimeClasspath
  jvmArgs = [
    '--add-opens=java.base/sun.nio.ch=ALL-UNNAMED'
  ]
}

/**
 * Demonstrates how Flux can be invoked via its public "Main" class, passing in command line options. This depends
 * on the "flux-api" dependency but uses the "Main" class instead of the Flux API interface. Requires Java 17
 * and use of the Gradle "java" plugin.
 */
tasks.register("runFluxMain", JavaExec) {
  description = "Demonstrates invoking Flux via its main class, allowing for CLI options to be passed to it."
  mainClass = "com.marklogic.flux.cli.Main"
  classpath = sourceSets.main.runtimeClasspath
  args = [
    "import-files",
    "--connection-string", "flux-example-user:password@localhost:8004",
    "--path", "../../flux-cli/src/test/resources/mixed-files",
    "--collections", "client-files",
    "--permissions", "flux-example-role,read,flux-example-role,update"
  ]
  jvmArgs = [
    '--add-opens=java.base/sun.nio.ch=ALL-UNNAMED'
  ]
}

/**
 * Demonstrates how Flux can be invoked via a custom Gradle task. This does not use the Gradle "java" plugin but rather
 * depends on the "flux-api" dependency being added to the Gradle buildscript classpath, as shown at the top of this
 * file. It also depends on the "org.gradle.jvmargs" option in this project's "gradle.properties" file which sets the
 * required "add-exports" options. The benefit of this approach is avoiding the need to create a separate Java class.
 * Requires Java 11 or 17 to run.
 */
tasks.register("runCustomTask") {
  doLast {
    Flux.importGenericFiles()
      .from("../../flux-cli/src/test/resources/mixed-files")
      .connectionString("flux-example-user:password@localhost:8004")
      .to({
        it.permissionsString("flux-example-role,read,flux-example-role,update")
          .collections("client-files")
      })
      .execute()
  }
}

